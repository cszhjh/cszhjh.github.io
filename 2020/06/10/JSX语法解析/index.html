
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zhjh&#39;s Blog || JSX语法解析</title>
    <meta name="author" content="Zhjh">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/favicon.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/full-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Zhjh's Blog</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Zhjh's Blog</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>JSX语法解析 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/6/10
        </span>

        
        <span class="category">
            <a href="/categories/React">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                React
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/JSX" style=color:#03a9f4>
                    JSX
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h2 id="认识-JSX-语法"><a href="#认识-JSX-语法" class="headerlink" title="认识 JSX 语法"></a>认识 JSX 语法</h2><pre><code class="lang-react">&lt;script type=&quot;text/babel&quot;&gt;
  const element = &lt;h2&gt;Hello World&lt;/h2&gt;
  ReactDOM.render(element, document.getElementById(&#39;app&#39;))
&lt;/script&gt;
</code></pre>
<ul>
<li><p>这段 <code>element</code> 变量声明赋值的标签语法是什么呢?</p>
<ul>
<li>它不是一段字符串(因为没有使用引号包裹), 它看起来像一段<code>HTML</code>元素, 但是我们能在 JS 中直接给一个变量赋值<code>HTML</code>吗?</li>
<li>其实是不可以的, 如果我们将<code>type=&quot;text/babel&quot;</code>去除掉, 那么就会出现语法错误</li>
<li>它到底是什么呢? 其实它是一段 JSX 的语法</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="JSX-是什么"><a href="#JSX-是什么" class="headerlink" title="JSX 是什么?"></a>JSX 是什么?</h3><p><strong>JSX 是一种 JavaScript 的语法扩展(eXtension)</strong>, 也在很多地方称之为 <strong>JavaScript XML</strong>, 因为它看起来就是一段 XML 语法</p>
<p>它用于描述我们的 UI 界面, 并且其完全可以和 JavaScript 融合在一起</p>
<p>它不同于 Vue 中的模板语法, 你不需要专门学习模版语法中的一些指令(如<code>v-for</code>、<code>v-if</code>、<code>v-else</code>、<code>v-bind</code>等)</p>
<h3 id="为什么-React-选择了-JSX"><a href="#为什么-React-选择了-JSX" class="headerlink" title="为什么 React 选择了 JSX?"></a>为什么 React 选择了 JSX?</h3><p>React 认为渲染逻辑本质上与其他 UI 逻辑存在<strong>内在耦合</strong></p>
<ul>
<li>比如 UI 需要绑定事件</li>
<li>比如 UI 需要展示数据状态, 在某些状态发生改变时, 又需要改变 UI</li>
</ul>
<p>他们之间时密不可分的, 所以 React 没有将标记分离到不同的文件中, 而是将它们组合到了一起, 这个地方就是组件(<code>Component</code>)</p>
<h3 id="JSX-的书写规范"><a href="#JSX-的书写规范" class="headerlink" title="JSX 的书写规范"></a>JSX 的书写规范</h3><p>JSX 的顶层<strong>只能有一个根元素</strong>, 所以我们很多使用会在外层包裹一个<code>div</code>元素</p>
<p>为了方便阅读, 我们通常在 JSX 的外层包裹一个小括号<code>()</code>, 这样可以方便阅读, 并且 JSX 可以进行换行书写</p>
<ul>
<li>不加小括号贸然换行会导致<code>render</code>函数返回<code>undefined</code>, 因为 JavaScript 会在<code>return</code>语句后面补上<strong>分号</strong></li>
</ul>
<p>JSX 中的标签可以是单标签, 也可以是双标签</p>
<ul>
<li>如果是单标签, 必须以<code>/&gt;</code>结尾</li>
</ul>
<h2 id="JSX-基础语法"><a href="#JSX-基础语法" class="headerlink" title="JSX 基础语法"></a>JSX 基础语法</h2><p>如果我们 JSX 中的内容是动态的, 我们可以通过表达式来获取</p>
<ul>
<li>书写规则: <code>&#123;JS 表达式&#125;</code></li>
<li>打括号内可以是变量、字符串、数组、函数调用等任意 JS 表达式</li>
</ul>
<h3 id="JSX-中的注释"><a href="#JSX-中的注释" class="headerlink" title="JSX 中的注释"></a>JSX 中的注释</h3><p>JSX 是嵌入到 JavaScript 中的一种语法, 所以在编写注释时, 需要通过 JSX 的语法来编写</p>
<pre><code class="lang-jsx">&lt;div&gt;
  &#123;/* 我是一段注释 */&#125;
  &lt;h2&gt;Hello World&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
<h3 id="JSX-嵌入变量"><a href="#JSX-嵌入变量" class="headerlink" title="JSX 嵌入变量"></a>JSX 嵌入变量</h3><ul>
<li>当变量是<code>Number</code>、<code>String</code>、<code>Array</code>类型时, 可以直接显示</li>
<li>当变量是<code>null</code>、<code>undefined</code>、<code>Boolean</code>类型时, 内容为空<ul>
<li>如果希望可以显示<code>null</code>、<code>undefined</code>、<code>Boolean</code>, 那么需要将其转成字符串</li>
<li>转换的方式有很多, 例如<code>toString</code>、<code>String(变量)</code>、空字符串拼接等方式</li>
</ul>
</li>
<li>对象和函数类型不能作为子元素(not valid as React child)</li>
</ul>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor() &#123;
    super()
    this.state = &#123;
      name: &#39;lion&#39;
      age: 18,
      language: [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;, &#39;c++&#39;, &#39;java&#39;]

      // 以下均不能显示
      test1: null,
      test2: undefined,
      flag: false,

      obj: &#123;
        name: &#39;coder&#39;
      &#125;
      func: function () &#123;&#125;
    &#125;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &#123;/* 1.可以直接显示 */&#125;
        &lt;h2&gt;&#123;this.state.name&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;this.state.age&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;this.state.language&#125;&lt;/h2&gt;

        &#123;/* 2.不显示 */&#125;
        &lt;h2&gt;&#123;this.state.test1&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;this.state.test2&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;this.state.flag&#125;&lt;/h2&gt;

        &#123;/* 3.不显示 */&#125;
        &lt;h2&gt;&#123;this.state.obj&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;this.state.func&#125;&lt;/h2&gt;

        &#123;/* 4.间接显示 */&#125;
        &lt;h2&gt;&#123;this.state.test1 + &#39;&#39;&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;this.state.test2 + &#39;&#39;&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;this.state.flag + &#39;&#39;&#125;&lt;/h2&gt;

        &lt;h2&gt;&#123;JSON.stringify(this.state.obj)&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;this.state.func + &#39;&#39;&#125;&lt;/h2&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;

ReactDOM.render(&lt;App/&gt;, document.getElementById(&quot;app&quot;))
</code></pre>
<p><strong>补充: 为什么<code>null</code>、<code>undefined</code>、<code>Boolean</code>在 JSX 中要显示为空内容呢?</strong></p>
<p>原因是在开发中, 我们会进行很多的判断</p>
<ul>
<li>在判断结果为<code>false</code>时, 不显示一个内容</li>
<li>在判断结果为<code>true</code>时, 显示一个内容</li>
</ul>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor() &#123;
    super()
    this.state = &#123;
      flag: false
    &#125;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &#123;this.state.flag ? &lt;h2&gt;我是标题&lt;/h2&gt;: null&#125;
        &#123;this.state.flag &amp;&amp; &lt;h2&gt;我是标题&lt;/h2&gt;&#125;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h3 id="JSX-嵌入表达式"><a href="#JSX-嵌入表达式" class="headerlink" title="JSX 嵌入表达式"></a>JSX 嵌入表达式</h3><p>JSX 中, 也可以是一个<strong>表达式</strong></p>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor() &#123;
    super()
    this.state = &#123;
      firstName: &#39;lion&#39;,
      lastName: &#39;coder&#39;,
      age: 20
    &#125;
  &#125;

  render() &#123;
    const &#123; firstName, lastName &#125; = this.state
    return (
      &lt;div&gt;
        &#123;/* 运算表达式 */&#125;
        &lt;h2&gt;&#123;firstName + &#39; &#39; + lastName&#125;&lt;/h2&gt;
        &#123;/* 三元运算符 */&#125;
        &lt;h2&gt;&#123;this.state.age &gt;= 18 ? &#39;成年人&#39;: &#39;未成年人&#39;&#125;&lt;/h2&gt;
        &#123;/* 执行一个函数 */&#125;
        &lt;h2&gt;&#123;this.sayHello(&#39;lion&#39;)&#125;&lt;/h2&gt;
      &lt;/div&gt;
    )
  &#125;

  sayHello(name) &#123;
    return &#39;Hello &#39; + name
  &#125;
&#125;
</code></pre>
<h3 id="JSX-绑定属性"><a href="#JSX-绑定属性" class="headerlink" title="JSX 绑定属性"></a>JSX 绑定属性</h3><p>很多时候, 描述的 HTML 元素会有一些属性, 而我们希望这些属性也是动态的, 如</p>
<ul>
<li><p>元素的<code>title</code>属性</p>
</li>
<li><p><code>img</code>元素的<code>src</code>属性</p>
</li>
<li><p><code>a</code>元素的<code>href</code>属性</p>
</li>
<li><p>元素的<code>class</code>属性</p>
<ul>
<li>注意: 绑定<code>class</code>比较特殊, 因为<code>class</code>在 JS 中是一个关键字, 所以 JSX 中不允许直接写<code>class</code></li>
<li>写法: 使用<code>className</code>替代</li>
</ul>
</li>
<li><p>元素使用内联样式<code>style</code></p>
<ul>
<li><code>style</code>后面跟的是一个对象类型, 对象的键值对是样式的<strong>属性名</strong>和<strong>属性值</strong></li>
<li>注意: 这里要将属性名转成<strong>驼峰标识</strong>, 而不是使用连接符<code>-</code></li>
</ul>
</li>
</ul>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor() &#123;
    super()
    this.state = &#123;
      title: &#39;你好啊&#39;,
      imgUrl: &#39;https://www.coderlion.com/images/user_img.jpeg&#39;,
      link: &#39;https://www.baidu.com&#39;,
      active: true
    &#125;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;h2 title=&#123;this.state.title&#125; style=&#123;&#123; fontSize: '18px', color: 'red' &#125;&#125;&gt;Hello World&lt;/h2&gt;
        &lt;img src=&#123;this.state.imgUrl&#125; style=&#123;&#123; width: '100px', height: '100px' &#125;&#125; alt=&quot;&quot; /&gt;
        &lt;a href=&#123;this.state.link&#125; target=&quot;_blank&quot;&gt;百度一下&lt;/a&gt;

        &#123;/* 两种方式都可以动态添加 class */&#125;
        &lt;div className=&#123;&#39;message &#39;&#39; + (this.state.active ? &#39;active&#39; : &#39;&#39;)&#125;&gt;你好啊&lt;/div&gt;
        &lt;div className=&#123;[&#39;message&#39;, (this.state.active ? &#39;active&#39; : &#39;&#39;)].join(&#39; &#39;)&#125;&gt;你好啊&lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h2 id="JSX-事件监听"><a href="#JSX-事件监听" class="headerlink" title="JSX 事件监听"></a>JSX 事件监听</h2><h3 id="与原生绑定的区别"><a href="#与原生绑定的区别" class="headerlink" title="与原生绑定的区别"></a>与原生绑定的区别</h3><p>如果原生 DOM 元素有一个监听事件, 我们如何操作呢?</p>
<ol>
<li>获取 DOM 元素, 添加监听事件</li>
<li>在 HTML 元素中, 直接绑定<code>onclick</code></li>
</ol>
<p>这里演练一下第二种方式</p>
<pre><code class="lang-html">&lt;button onclick=&quot;btnClick()&quot;&gt;button&lt;/button&gt;
&lt;script&gt;
  function btnClick() &#123;
    console.log(&#39;click&#39;)
  &#125;
&lt;/script&gt;
</code></pre>
<p><code>btnClick()</code>这样写的原因是<code>onclick</code>绑定的后面是跟上 JavaScript 代码</p>
<p>我们来实现一下 React 中的事件监听, 这里主要有两点不同</p>
<ol>
<li>React 事件的命名采用<strong>小驼峰式(camelCase)</strong>, 而不是纯小写</li>
<li>我们需要通过<code>&#123;&#125;</code>传入一个事件处理函数, 这个函数会在事件发生时被执行</li>
</ol>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor() &#123;
    super()
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;this.btnClick&#125;&gt;button&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;

  btnClick() &#123;
    console.log(&#39;click&#39;)
  &#125;
&#125;
</code></pre>
<h3 id="this-绑定问题"><a href="#this-绑定问题" class="headerlink" title="this 绑定问题"></a>this 绑定问题</h3><p>在事件执行后, 我们可能需要获取当前类的对象中相关的属性</p>
<ul>
<li><p>比如我们这里打印: <code>this.state.message</code></p>
<ul>
<li>但是这里会报错: <code>Cannot read property &#39;state&#39; of undefined</code></li>
</ul>
</li>
<li>原因是<code>this</code>在这里是<code>undefined</code></li>
</ul>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)

    this.state = &#123;
      message: &#39;Hello React&#39;
    &#125;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;this.btnClick&#125;&gt;button&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;

  btnClick() &#123;
    // undefined
    console.log(this)
    // Cannot read property &#39;state&#39; of undefined
    console.log(this.state.message)
  &#125;
&#125;
</code></pre>
<p>为什么<code>this</code>会是<code>undefined</code>呢?</p>
<ul>
<li>原因是<code>btnClick</code>函数并不是我们主动调用的, 而且当<code>button</code>发生点击时, React 内部调用了<code>btnClick</code>函数</li>
<li>而它内部调用时, 并不知道要如何绑定正确的<code>this</code></li>
</ul>
<h4 id="bind-给-btnClick-显示绑定-this"><a href="#bind-给-btnClick-显示绑定-this" class="headerlink" title="bind 给 btnClick 显示绑定 this"></a>bind 给 btnClick 显示绑定 this</h4><p>在传入函数时, 我们可以主动绑定<code>this</code></p>
<ul>
<li>这里我们主动将<code>btnClick</code>中的<code>this</code>通过<code>bind</code>来进行绑定(显示绑定)</li>
<li>那么之后 React 内部调用<code>btnClick</code>函数时, 就会有一个<code>this</code>, 并且是我们绑定的<code>this</code></li>
</ul>
<pre><code class="lang-jsx">&lt;button onClick=&#123;this.btnClick.bind(this)&#125;&gt;button&lt;/button&gt;
</code></pre>
<p>但是呢, 如果我有两个函数都需要用到<code>btnClick</code>的绑定</p>
<p>我们发现<code>bind(this)</code>需要书写两遍</p>
<pre><code class="lang-jsx">&lt;button onClick=&#123;this.btnClick.bind(this)&#125;&gt;button1&lt;/button&gt;
&lt;button onClick=&#123;this.btnClick.bind(this)&#125;&gt;button2&lt;/button&gt;
</code></pre>
<p>这个问题我们可以通过在构造方法中直接给<code>this.btnClick</code>绑定<code>this</code>来解决</p>
<ul>
<li>注意查看<code>constructor</code>中我们的操作<code>this.btnClick = this.btnClick.bind(this)</code></li>
</ul>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)

    this.state = &#123;
      message: &#39;Hello React&#39;
    &#125;

    this.btnClick = this.btnClick.bind(this)
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;this.btnClick&#125;&gt;button1&lt;/button&gt;
        &lt;button onClick=&#123;this.btnClick&#125;&gt;button2&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;

  btnClick() &#123;
    console.log(this)    // App
    console.log(this.state.message) // Hello React
  &#125;
&#125;
</code></pre>
<h4 id="使用-ES6-class-fields-语法"><a href="#使用-ES6-class-fields-语法" class="headerlink" title="使用 ES6 class fields 语法"></a>使用 ES6 class fields 语法</h4><p>你会发现我这里将<code>btnClick</code>的定义变成了一种赋值语句</p>
<ul>
<li>这里 ES6 中给类定义属性的方法, 称之为 <strong>class fields</strong> 语法</li>
<li>因为这里我们赋值时, 使用了箭头函数, 所以在当前函数中的<code>this</code>会去上一个<strong>作用域</strong>中查找</li>
<li>而上一个作用域的<code>this</code>就是当前对象<code>App</code></li>
</ul>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)

    this.state = &#123;
      message: &#39;Hello React&#39;
    &#125;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;this.btnClick&#125;&gt;button1&lt;/button&gt;
        &lt;button onClick=&#123;this.btnClick&#125;&gt;button2&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;

  btnClick = () =&gt; &#123;
    console.log(this)    // App
    console.log(this.state.message) // Hello React
  &#125;
&#125;
</code></pre>
<h4 id="事件监听时传入箭头函数-推荐"><a href="#事件监听时传入箭头函数-推荐" class="headerlink" title="事件监听时传入箭头函数(推荐)"></a>事件监听时传入箭头函数(推荐)</h4><p>因为<code>onClick</code>中要求我们传入一个函数, 那么我们可以直接定义一个箭头函数传入</p>
<ul>
<li>传入的箭头函数的函数体是我们需要执行的代码, 我们直接执行<code>this.btnClick()</code></li>
<li><code>this.btnClick()</code>中通过<code>this</code>来指定会进行隐式绑定, 最终<code>this</code>也是正确的</li>
</ul>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)

    this.state = &#123;
      message: &#39;Hello React&#39;
    &#125;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;() =&gt; this.btnClick()&#125;&gt;button1&lt;/button&gt;
        &lt;button onClick=&#123;() =&gt; this.btnClick()&#125;&gt;button2&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;

  btnClick() &#123;
    console.log(this)    // App
    console.log(this.state.message) // Hello React
  &#125;
&#125;
</code></pre>
<h3 id="事件参数传递"><a href="#事件参数传递" class="headerlink" title="事件参数传递"></a>事件参数传递</h3><p>在执行事件函数时, 有可能我们需要获取一些参数信息, 例如<code>event</code>对象, 其他参数等</p>
<h4 id="获取-event-对象"><a href="#获取-event-对象" class="headerlink" title="获取 event 对象"></a>获取 event 对象</h4><p>很多使用我们需要拿到<code>event</code>对象来做一些事情(比如阻止默认行为)</p>
<p>假如我们用不到<code>this</code>, 那么可以直接传入函数就可以获取到<code>event</code>对象</p>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;a href=&quot;http://www.baidu.com&quot; onClick=&#123;this.btnClick&#125;&gt;百度一下&lt;/a&gt;
      &lt;/div&gt;
    )
  &#125;

  btnClick(event) &#123;
    event.preventDefault()    // 阻止 a 标签默认行为
    console.log(event)    // event object
  &#125;
&#125;
</code></pre>
<h4 id="获取更多参数"><a href="#获取更多参数" class="headerlink" title="获取更多参数"></a>获取更多参数</h4><p>有更多参数时, 我们最好的方式就是传入一个箭头函数, 主动执行的事件函数, 并且传入相关的其他参数</p>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)

    this.state = &#123;
      names: [&#39;衣服&#39;, &#39;鞋子&#39;, &#39;裤子&#39;]
    &#125;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;a href=&quot;http://www.baidu.com&quot; onClick=&#123;this.aClick&#125;&gt;百度一下&lt;/a&gt;

        &#123;
          this.state.names.map((item, index) =&gt; &#123;
            return (
              &lt;a href=&quot;#&quot; onClick=&#123;event =&gt; this.aClick(event, item, index)&#125;&gt;&#123;item&#125;&lt;/a&gt;
            )
          &#125;)
        &#125;
      &lt;/div&gt;
    )
  &#125;

  aClick(event, item, index) &#123;
    e.preventDefault()
    console.log(item, index)
    console.log(event)
    /*
      百度一下: undefined, undefined, event object
      衣服: &#39;衣服&#39;, 0, event object
      鞋子: &#39;鞋子&#39;, 1, event object
      裤子: &#39;裤子&#39;, 2, event object
    */
  &#125;
&#125;
</code></pre>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>某些情况下, 界面的内容会根据不同的情况显示不同的内容, 或者决定是否渲染某部分内容</p>
<ul>
<li>在 Vue 中, 我们一般通过指令来控制: <code>v-if</code>、<code>v-show</code></li>
<li>在 React 中, 所有的条件判断都和普通的 JavaScript 代码一致</li>
</ul>
<h3 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h3><p>一种方式是当逻辑较多时, 通过条件判断</p>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)

    this.state = &#123;
      isLogin: true
    &#125;
  &#125;

  render() &#123;
    let titleJsx = null
    if (this.state.isLogin) &#123;
      titleJsx = &lt;h2&gt;欢迎回来~&lt;/h2&gt;
    &#125; else &#123;
      titleJsx = &lt;h2&gt;请先登录~&lt;/h2&gt;
    &#125;

    return (
      &lt;div&gt;
        &#123;titleJsx&#125;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>另外一种实现条件渲染的方法就是<strong>三元运算符</strong></p>
<p>三元运算符适用于没有太多逻辑的代码: 只是根据不同的条件直接返回不同的结果</p>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)

    this.state = &#123;
      isLogin: true
    &#125;
  &#125;

  render() &#123;
    const &#123; isLogin &#125; = this.state
    return (
      &lt;div&gt;
        &lt;h2&gt;&#123;isLogin ? &#39;欢迎回来~&#39;: &#39;请先登录~&#39;&#125;&lt;/h2&gt;
        &lt;button onClick=&#123;e =&gt; this.loginBtnClick()&#125;&gt;&#123;isLogin ? &#39;退出&#39;: &#39;登录&#39;&#125;&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;

  loginBtnClick() &#123;
    this.setState(&#123;
      isLogin: !this.state.isLogin
    &#125;)
  &#125;
&#125;
</code></pre>
<h3 id="与运算符-amp-amp"><a href="#与运算符-amp-amp" class="headerlink" title="与运算符 &amp;&amp;"></a>与运算符 &amp;&amp;</h3><p>在某些情况下, 我们会遇到这样的场景</p>
<ul>
<li>如果条件成立, 渲染某一个组件</li>
<li>反之, 什么内容都不渲染</li>
</ul>
<p>如果我们使用三元运算符, 是如何做呢?</p>
<pre><code class="lang-react">&#123;this.state.isLogin ? &lt;h2&gt;&#123;this.state.username&#125;&lt;/h2&gt; : null&#125;
</code></pre>
<p>其实我们可以通过<strong>逻辑与 &amp;&amp;</strong> 来简化操作</p>
<pre><code class="lang-react">&#123;this.state.isLogin &amp;&amp; &lt;h2&gt;&#123;this.state.username&#125;&lt;/h2&gt;&#125;
</code></pre>
<h3 id="v-show-效果"><a href="#v-show-效果" class="headerlink" title="v-show 效果"></a>v-show 效果</h3><p>针对一个 HTML 元素, 渲染和不渲染之间, 如果切换的非常频繁, 那么会相对比较损耗性能</p>
<ul>
<li>在开发中,其实我们可以通过<code>display</code>的属性来控制它的显示和隐藏</li>
<li>这种控制方式在 Vue 中有一个专门的指令: <code>v-show</code></li>
<li>React 没有指令, 但是 React 会更加灵活(灵活带来的代价就是需要自己实现)</li>
</ul>
<pre><code class="lang-react">render() &#123;
  const &#123; isLogin, username &#125; = this.state
  const nameDisplay = isLogin ? &#39;block&#39;: &#39;none&#39;

  return (
    &lt;div&gt;
      &lt;h2 style=&#123;&#123;display: nameDisplay&#125;&#125;&gt;&#123;username&#125;&lt;/h2&gt;
      &lt;button onClick=&#123;e =&gt; this.loginBtnClick()&#125;&gt;&#123;isLogin ? &#39;退出&#39;: &#39;登录&#39;&#125;&lt;/button&gt;
    &lt;/div&gt;
  )
&#125;
</code></pre>
<h2 id="JSX-列表渲染"><a href="#JSX-列表渲染" class="headerlink" title="JSX 列表渲染"></a>JSX 列表渲染</h2><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>真实开发中我们会从服务器请求到大量的数据, 数据会以列表的形式存储</p>
<ul>
<li>如歌曲、歌手、排行榜列表的数据</li>
<li>如商品、购物车、评论列表的数据</li>
<li>如好友消息、动态、联系人列表的数据</li>
</ul>
<p>在 React 中并没有像 Vue 模版语法中的<code>v-for</code>指令, 而且需要我们通过 JavaScript 代码的方式组织数据, 转成 JSX</p>
<ul>
<li>在 React 中, 展示类标最多的方式就是使用数组的<code>map</code>高阶函数</li>
</ul>
<pre><code class="lang-react">let new_array = arr.map(function callback(currentValue, index, array) &#123;
 // Return element for new_array 
&#125;, thisArg)
</code></pre>
<ul>
<li><p><code>callback</code>: 生成新数组元素的回调函数, 使用三个参数:</p>
<ul>
<li><code>currentValue</code>: 数组中正在处理的当前元素</li>
<li><code>index</code>(可选): 数组中正在处理的当前元素的索引</li>
<li><code>array</code>(可选): <code>map</code>方法调用的数组</li>
</ul>
</li>
<li><p><code>shitArg</code>(可选): 执行<code>callback</code>函数时值被用作<code>this</code></p>
</li>
</ul>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)

    this.state = &#123;
      musics: [&#39;My World&#39;, &#39;No Name&#39;, &#39;Freedom&#39;, &#39;White Angel&#39;, &#39;The Way&#39;]
    &#125;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;h2&gt;歌曲列表&lt;/h2&gt;
        &lt;ul&gt;
          &#123;
            this.state.musics.map(item =&gt; &lt;li&gt;&#123;item&#125;&lt;/li&gt;)
          &#125;
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h3 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h3><p>很多时候我们在展示一个数组中的数据之前, 需要先对它进行一些处理</p>
<ul>
<li>如过滤掉一些内容: <code>filter</code>函数</li>
<li>如截取数组中的一部分内容: <code>slice</code>函数</li>
</ul>
<p>例如这样一列数字: <code>[10, 30, 77, 24, 99, 95, 21, 111, 233, 311]</code></p>
<p>案例需求: 获取所有大于 50 的数字, 并展示前 3 个数字</p>
<pre><code class="lang-react">class App extends React.Component &#123;
  constructor(props) &#123;
    super(props)

    this.state = &#123;
      numbers: [10, 30, 77, 24, 99, 95, 21, 111, 233, 311]
    &#125;
  &#125;

  render() &#123;
    const &#123; numbers &#125; = this.state

    return (
      &lt;div&gt;
        &lt;h2&gt;数字列表&lt;/h2&gt;
        &lt;ul&gt;
          &#123;
            numbers.filter(item =&gt; item &gt; 50).slice(0, 3).map(item =&gt; &lt;li&gt;&#123;item&#125;&lt;/li&gt;)
          &#125;
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h3 id="列表的-key"><a href="#列表的-key" class="headerlink" title="列表的 key"></a>列表的 key</h3><p>我们会发现在前面的代码中只要展示列表都会报一个<strong>警告</strong></p>
<p><a target="_blank" rel="noopener" href="https://s1.ax1x.com/2020/06/13/tvdTAA.png"><img src="https://s1.ax1x.com/2020/06/13/tvdTAA.png" alt="tvdTAA.png"></a></p>
<p>这个警告是告诉我们需要在列表展示的 JSX 中添加一个<code>key</code>值</p>
<p>至于如何添加一个<code>key</code>, 为什么要添加一个<code>key</code>, 这个我们放到后面讲解<code>setState</code>时再来讨论</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>

                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2021 Zhjh&#39;s Blog
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Zhjh
        </div>
        <!-- <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
        <div> -->
            备案号：<a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">
                琼ICP备 - 20001325号
            </a>
        </div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>

                </div>
            </div>
        </transition>
        
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="js/md5.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: 'ce37b7d644656285b3f6',
        clientSecret: '3b328b4c8ec578d1e5c6bd874b247060ca91df29',
        repo: 'blog-comment',      // The repository of store comments,
        owner: 'cszhjh',
        admin: ['cszhjh'],
        language: 'zh-CN',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>


</body>

</html>
