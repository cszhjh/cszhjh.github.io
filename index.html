
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zhjh&#39;s Blog || To strive, to seek, to find, and not to yield.</title>
    <meta name="author" content="Zhjh">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/favicon.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/full-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Zhjh's Blog</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Zhjh's Blog</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('/home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Zhjh's Blog</h1>
                <h3>To strive, to seek, to find, and not to yield.</h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2021/12/24/C++之基于词典与Trie的中文分词/">
        <h2>
            C++之基于词典与Trie的中文分词
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/C++">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                C++
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/12/24
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>中文分词算法在搜索引擎和机器学习中有着广泛的应用，该算法大致分为基于词典规则与基于机器学习两种方式。由于中文语句是由连续的汉字所组成，因此不能使用类似英文以标点符号以及空格作为分隔符进行分词，中文分词需要考虑语义及上下文语境。本文主要介绍基于词典规则的中文分词，并使用<strong>Trie</strong>结构进行搜索优化。</p>
<h2 id="中文分词方法概述"><a href="#中文分词方法概述" class="headerlink" title="中文分词方法概述"></a>中文分词方法概述</h2><h3 id="基于词典规则的中文分词方法"><a href="#基于词典规则的中文分词方法" class="headerlink" title="基于词典规则的中文分词方法"></a>基于词典规则的中文分词方法</h3><p>基于词典规则的中文分词是一种根据规则以及建立词典并不断地对词典进行维护的分词技术。使用这种技术分词之前，需要准备一个<strong>相对完备的分词词典</strong>，使其尽可能包含更多的词。然后将待处理文本通过以下三种方式进行切分，将切法的结果与词典中的词进行匹配，如果词典中存在该词，则认为该词被成功切分，如果词典中不存在相应的词，则进行重新切分。</p>
<h4 id="正向最长匹配"><a href="#正向最长匹配" class="headerlink" title="正向最长匹配"></a>正向最长匹配</h4><p>正向最长匹配是将被切分的句子从左至右扫描，然后根据句子的<strong>最大长度</strong>依次递减地截取一个候选词，把当前候选词与词典中的词进行比较。如果匹配成功，则认为该候选词是一个词，继续对原句子中该候选词的下一个位置进行重复操作；如果匹配失败，则认为该候选词不是一个词，通过在句子的最右端去掉一个字继续扫描。例如，要将句子“就读北京大学”进行分词，按照正向最大匹配算法有以下流程：</p>
<ol>
<li>第一轮<br>i.    将“就读北京大学作为候选词”，词典中没有对应的词，匹配失败；<br>ii.    从最右端去除一个字，将“就读北京大”作为候选词，词典中没有对应的词，匹配失败；<br>iii.    从最右端去除一个字，将“就读北京”作为候选词，词典中没有对应的词，匹配失败；<br>iv.    从最右端去除一个字，将“就读北”作为候选词，词典中没有对应的词，匹配失败；<br>v.    从最右端去除一个字，将“就读”作为候选词，词典中有对应的词，匹配成功；<br>扫描终止，保存第一个单词“就读”，去除第一个单词开始第二轮扫描。</li>
<li>第二轮<br>i.    从上一个单词下一个位置开始从前往后选取候选词。“北京大学”，词典中有对应的词，匹配成功。</li>
<li>扫描终止，保存第二个单词“北京大学”，搜索结束，返回结果。</li>
</ol>
<p>至此，通过<strong>正向最长匹配</strong>对“就读北京大学”的匹配结果为：“<code>就读 / 北京大学</code>”。<br>正向最长匹配算法的优点是<strong>切分速度快</strong>，实现简单，但相关实验数据表明正向最长匹配算法的分词错误率大约为 <code>0.58%</code>。<br>在Windows平台下，使用C++进行编写时一般为<strong>GB2312</strong>编码，该编码是一种定长编码，即汉字为两个字节，英文为一个字节。对于传入的文本，需要将其每个字都单独获取出来才能进行匹配。<br>以下为获取单个字的C++代码实现</p>
<pre><code class="lang-c++">/**
 * 切割字符串，将每个字（中/英）拆成若干个字符串，并存入数组中，数组的每一个元素为单词的每一个字
 * @param word 单词
 * @param characters 存放单词拆分结果的数组
 */
void split_word(const string &amp;word, vector&lt;string&gt; &amp;characters) &#123;
    for (int i = 0; i &lt; word.size(); i++) &#123;
        if ((unsigned) word[i] &gt; 0x80) &#123;
            // 无符号GBK编码
            characters.push_back(word.substr(i, 2));
            i++;
        &#125; else &#123;
            characters.push_back(word.substr(i, 1));
        &#125;
    &#125;
&#125;
</code></pre>
<p>之后便可以实现正向最长匹配算法，如下</p>
<pre><code class="lang-c++">/**
 * 正向分词算法
 * @param text 待分词字符串 
 * @return 分词结果单词数组
 */
vector&lt;string&gt; forward_segment(const string &amp;text) &#123;
    vector&lt;string&gt; word_list, characters;
        // 获取单字数组
    split_word(text, characters);
    for (int i = 0; i &lt; characters.size();) &#123;
        string longest_word = characters[i];
        int word_size = 1;
        for (int j = characters.size() - 1; j &gt;= i; j--) &#123;
            string word;
                        // 截取候选词
            for (int k = i; k &lt;= j; k++) &#123;
                word += characters[k];
            &#125;
              // 匹配单词
            if (search(word) &amp;&amp; word.size() &gt; longest_word.size()) &#123;
                longest_word = word;
                word_size = j - i + 1;
                break;
            &#125;
        &#125;
        word_list.push_back(longest_word);
        i += word_size;
    &#125;
    return word_list;
&#125;
</code></pre>
<p>使用上面代码对“就读北京大学”进行分词，具体代码流程如图所示：</p>
<table style="text-align: center">
    <tr>
        <th align="center">i</th>
        <th align="center">i < characters.size()</th>
        <th align="center">j</th>
        <th align="center">word</th>
        <th align="center">是否在词典中</th>
        <th align="center">longest_word</th>
    </tr>
    <tr>
        <td align="center" rowspan="5">0</td>
        <td align="center" rowspan="5">0 < 6</td>
        <td>5</td>
        <td>就读北京大学</td>
        <td>否</td>
        <td>就</td>
    </tr>
    <tr>
        <td>4</td>
        <td>就读北京大</td>
        <td>否</td>
        <td>就</td>
    </tr>
    <tr>
        <td>3</td>
        <td>就读北京</td>
        <td>否</td>
        <td>就</td>
    </tr>
    <tr>
        <td>2</td>
        <td>就读北</td>
        <td>否</td>
        <td>就</td>
    </tr>
    <tr>
        <td>1</td>
        <td>就读</td>
        <td>是</td>
        <td>就读</td>
    </tr>
    <tr>
        <td colspan="6">“就读”被分出，去掉“就读”后处理文本为“北京大学”</td>
    </tr>
</table>


<p>正向最长匹配分词结果为“就读 / 北京大学”</p>
<h4 id="逆向最长匹配"><a href="#逆向最长匹配" class="headerlink" title="逆向最长匹配"></a>逆向最长匹配</h4><p>逆向最长匹配算法和正向最长匹配算法的原理类似，区别在于逆向最大匹配算法的扫描方向是从右向左的，如果匹配失败，则去掉左端的一个字。<br>例：对“研究生命起源”进行分词</p>
<ol>
<li>第一轮<br>i.    将“研究生命起源”作为候选词，词典中没有对应的词，匹配失败。<br>ii.    左边减少一个字，将“究生命起源”作为候选词，词典中没有对应的词，匹配失败。<br>iii.    左边减少一个字，将“生命起源”作为候选词，词典中没有对应的词，匹配失败。<br>iv.    左边减少一个字，将“命起源”作为候选词，词典中没有对应的词，匹配失败。<br>v.    左边减少一个字，将“起源”作为候选词，词典中有对应的词，匹配成功。<br>扫描终止，保存第一个单词“起源”，去除第一个单词开始第二轮扫描。</li>
<li>第二轮<br>i.    将“研究生命”作为候选词，词典中没有对应的词，匹配失败。<br>ii.    将“究生命”作为候选词，词典中没有对应的词，匹配失败。<br>iii.    将“生命”作为候选词，词典中有对应的词，匹配成功。<br>扫描终止，保存第二个单词“生命”，去除第二个单词开始第三轮扫描。</li>
<li>第三轮<br>i.    将“研究”作为候选词，词典中有对应的词，匹配成功。</li>
<li>扫描终止，保存第三个单词“研究”，搜索结束，返回结果。</li>
</ol>
<p>至此，通过逆向最长匹配对“研究生命科学”的匹配结果为：“研究 / 生命 / 科学”。<br>实验数据表明，逆向最长匹配算法的分词错误率大约为 0.41%，切分精准率比正向最长匹配算法略高。<br>实现逆向最长匹配算法，如下</p>
<pre><code class="lang-c++">/**
 * 逆向分词
 * @param text 待分词字符串
 * @return 分词结果单词数组
 */
vector&lt;string&gt; backward_segment(const string &amp;text) &#123;
    vector&lt;string&gt; word_list, characters;
    // 获取单字数组
    split_word(text, characters);

    for (int i = characters.size() - 1; i &gt;= 0;) &#123;
        string longest_word = characters[i];
        int word_size = 1;
        for (int j = 0; j &lt;= i; j++) &#123;
            string word;
            // 截取候选词
            for (int k = j; k &lt;= i; k++) &#123;
                word += characters[k];
            &#125;
            // 匹配单词
            if (search(word) &amp;&amp; word.size() &gt; longest_word.size()) &#123;
                longest_word = word;
                word_size = i - j + 1;
                break;
            &#125;
        &#125;
        word_list.insert(word_list.begin(), longest_word);
        i -= word_size;
    &#125;
    return word_list;
&#125;
</code></pre>
<p>使用上面代码对“研究生命起源”进行分词，具体代码流程如图所示：</p>
<table style="text-align: center">
    <tr>
        <th align="center">i</th>
        <th align="center">i >= 0</th>
        <th align="center">j</th>
        <th align="center">word</th>
        <th align="center">是否在词典中</th>
        <th align="center">longest_word</th>
    </tr>
    <tr>
        <td align="center" rowspan="5">5</td>
        <td align="center" rowspan="5">5 >= 0</td>
        <td>0</td>
        <td>研究生命起源</td>
        <td>否</td>
        <td>源</td>
    </tr>
    <tr>
        <td>1</td>
        <td>究生命起源</td>
        <td>否</td>
        <td>源</td>
    </tr>
    <tr>
        <td>2</td>
        <td>生命起源</td>
        <td>否</td>
        <td>源</td>
    </tr>
    <tr>
        <td>3</td>
        <td>命起源</td>
        <td>否</td>
        <td>源</td>
    </tr>
    <tr>
        <td>4</td>
        <td>起源</td>
        <td>是</td>
        <td>起源</td>
    </tr>
    <tr>
        <td colspan="6">“起源”被分出，去掉“起源”后处理文本为“研究生命”</td>
    </tr>
  <tr>
        <td align="center" rowspan="3">3</td>
        <td align="center" rowspan="3">3 >= 0</td>
        <td>0</td>
        <td>研究生命</td>
        <td>否</td>
        <td>命</td>
    </tr>
    <tr>
        <td>1</td>
        <td>究生命</td>
        <td>否</td>
        <td>命</td>
    </tr>
    <tr>
        <td>2</td>
        <td>生命</td>
        <td>是</td>
        <td>生命</td>
    </tr>
    <tr>
        <td colspan="6">“生命”被分出，去掉“生命”后处理文本为“研究”</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1 >= 0</td>
        <td>0</td>
        <td>研究</td>
        <td>是</td>
        <td>研究</td>
    </tr>
    <tr>
        <td colspan="6">逆向最长匹配分词结果为“研究 / 生命 / 科学”</td>
    </tr>
</table>

<h4 id="双向最长匹配"><a href="#双向最长匹配" class="headerlink" title="双向最长匹配"></a>双向最长匹配</h4><p>双向最长匹配是通过某些规则选择使用正向或逆向最长匹配算法进行分词，因为在相同的句子中，有时会出现正向最长匹配正确，而有时逆向最长匹配正确。因此有人提出了融合正向最长匹配和逆向最长匹配向融合的双向最长匹配。其实现方法是同时执行正向最长匹配和逆向最长匹配，然后在给定的一些规则中选择最优，本质上是两种算法中二选一。<br>择优规则：</p>
<ul>
<li>正向最长匹配和逆向最长匹配分词后的词数不同，返回词数更少的结果。</li>
<li>正向最长匹配和逆向最长匹配分词后的词数相同，返回不在词典中的词和单字词最少的结果。</li>
<li>如果正向最长匹配的词数以及不在词典中的词和单字词都相同的情况下，优先返回逆向最长匹配的结果。</li>
</ul>
<p>双向最长匹配的代码如下：</p>
<pre><code class="lang-C++">/**
 * 双向匹配
 * @param text 待分词字符串 
 * @return 分词结果单词数组
 */
vector&lt;string&gt;bidirectional_segment(const string &amp;text) &#123;
    vector&lt;string&gt; f, b;
    f = this-&gt;forward_segment(text, fwc);
    b = this-&gt;backward_segment(text, bwc);

    if (f.size() &lt; b.size()) &#123;
        return f;
    &#125; else if (f.size() &gt; b.size()) &#123;
        return b;
    &#125; else &#123;
        if (this-&gt;count_single_char(f) &lt; this-&gt;count_single_char(b)) &#123;
            return f;
        &#125;
        return b;
    &#125;
&#125;
</code></pre>
<h3 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h3><p>匹配算法的瓶颈之一在于如何判断词典中是否含有字符串。如果用有序列表（TreeMap）的话，时间复杂度是<code>O(logN)</code>（N是词典大小）。如果用散列表（Java的HashMap，Python的dict）的话，表面上时间复杂度虽然降下去了，但内存复杂度却上去了。有没有速度又快、内存又省的数据结构呢？有，那便是字典树。</p>
<h4 id="什么是字典树"><a href="#什么是字典树" class="headerlink" title="什么是字典树"></a>什么是字典树</h4><p>字符串集合常用字典树（Trie树、前缀树）存储，它的查询时间复杂度可以达到常数级<code>O(1)</code>，这是一种字符串上的树形数据结构。字典树中每条边都对应一个字，从根节点往下的路径构成一个个字符串。字典树并不直接在节点存储字符串，而是将词语视作根节点到某节点之间的一条路径，并在终点节点（蓝色）上做个标记，该节点对应词语的结尾。字符串就是一条路径，要查询一个单词，只需顺着这条路径从根节点往下走。如果最后能走到特殊标记的节点，则说明该字符串在集合中，否则说明不存在。根节点一般什么都不保存，其他节点通常有两个属性（<code>pass</code>, <code>end</code>），<code>pass</code>表示当前节点通过了几次，<code>end</code>表示这个节点成为了多少个词的结尾。一个典型的字典树如下图所示。</p>
<h4 id="字典树的实现"><a href="#字典树的实现" class="headerlink" title="字典树的实现"></a>字典树的实现</h4><p>由上图可知，每个节点都应该至少知道自己的子节点与对应的变，以及自己是否对应一个词。所以在每个节点中，使用<code>unordered_map</code>存储子节点，并用<code>end</code>表示其是否为一个词。</p>
<pre><code class="lang-c++">class Node &#123;
public:
    int pass;   // 经过次数
    int end;    // 结尾次数
    unordered_map&lt;string, Node *&gt; nexts;    // 子结点集合

    Node();
&#125;;

class Trie &#123;
private:
    Node *root;
public:
    Trie();

    ~Trie();

    void insert(const string &amp;);

    int search(const string &amp;);

    void split_word(const string &amp;, vector&lt;string&gt; &amp;);

    void clear(Node *);
&#125;;
</code></pre>
<p>初始化类对象</p>
<pre><code class="lang-C++">Node::Node() &#123;
    this-&gt;pass = 0;
    this-&gt;end = 0;
&#125;

Trie::Trie() &#123;
    this-&gt;root = new Node();
&#125;

Trie::~Trie() &#123;
    clear(this-&gt;root);
    delete this-&gt;root;
&#125;
</code></pre>
<p>具体功能实现如下</p>
<pre><code class="lang-c++">/**
 * 将单词插入到Trie中
 * @param word 单词字符串
 */
void Trie::insert(const string &amp;word) &#123;
    if (word.empty()) &#123;
        return;
    &#125;
    Node *node = this-&gt;root;
    vector&lt;string&gt; characters;
    this-&gt;split_word(word, characters); // 获取每一个字的集合
    node-&gt;pass++;
    for (int i = 0; i &lt; characters.size(); i++) &#123;
        if (node-&gt;nexts.find(characters[i]) == node-&gt;nexts.end()) &#123;
            // 该字不在字结点集合中，则将其作为结点插入
            node-&gt;nexts[characters[i]] = new Node();
        &#125;
        node = node-&gt;nexts[characters[i]];
        node-&gt;pass++;
    &#125;
    node-&gt;end++;
&#125;

/**
 * 查询Trie中是否存在该单词，即 end != 0
 * @param word 单词字符串
 * @return 该单词结尾次数
 */
int Trie::search(const string &amp;word) &#123;
    if (word.empty()) &#123;
        return 0;
    &#125;
    Node *node = this-&gt;root;
    vector&lt;string&gt; characters;
    this-&gt;split_word(word, characters); // 获取每一个字的集合
    for (int i = 0; i &lt; characters.size(); i++) &#123;
        if (node-&gt;nexts.find(characters[i]) == node-&gt;nexts.end()) &#123;
            // 该字不在子结点集合中，则没有以该单词为结尾的词
            return 0;
        &#125;
        node = node-&gt;nexts[characters[i]];
    &#125;
    return node-&gt;end;
&#125;

/**
 * 切割字符串，将每个字（中/英）拆成若干个字符串，并存入数组中，数组的每一个元素为单词的每一个字
 * @param word 单词
 * @param characters 存放单词拆分结果的数组
 */
void Trie::split_word(const string &amp;word, vector&lt;string&gt; &amp;characters) &#123;
    for (int i = 0; i &lt; word.size(); i++) &#123;
        if ((unsigned) word[i] &gt; 0x80) &#123;
            // 无符号GBK编码
            characters.push_back(word.substr(i, 2));
            i++;
        &#125; else &#123;
            characters.push_back(word.substr(i, 1));
        &#125;
    &#125;
&#125;

void Trie::clear(Node *node) &#123;
    if (!node || node-&gt;nexts.empty()) &#123;
        return;
    &#125;
    for (unordered_map&lt;string, Node *&gt;::iterator it = node-&gt;nexts.begin(); it != node-&gt;nexts.end(); it++) &#123;
        this-&gt;clear(it-&gt;second);
        delete it-&gt;second;
    &#125;
    node-&gt;nexts.clear();
&#125;
</code></pre>
<h2 id="结-论"><a href="#结-论" class="headerlink" title="结  论"></a>结  论</h2><p>本文研究了中文分词算法，中文分词作为信息检索、机器翻译、语音识别、搜索引擎的基础，广泛应用于各个领域中，中文分词的准确率和效率会直接影响到后续应用的效果，所以研究高效又准确的中文分词算法十分重要，本文针对最长匹配算法主要工作包括以下几个方面：</p>
<ol>
<li>总结了三种最长匹配分词算法，并分别对比了每类分词方法的优缺点。</li>
<li>针对基于词典的中文分词匹配效率低的问题，将字典树与分词相结合，使得其每次匹配的时间都控制在<code>O(1)</code>，在很大程度上提高了分词效率。</li>
</ol>
<p>参考文献：<br>[1] 赵悦. 基于词语分类和排序的最大匹配中文分词技术[D]. 沈阳：沈阳师范大学, 2020.</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/中文分词" style=color:#03a9f4>
                中文分词
            </a>
        </span>
        
    </div>

    <a href="/2021/12/24/C++之基于词典与Trie的中文分词/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/10/27/邂逅NodeJS/">
        <h2>
            邂逅Node.js
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/10/27
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="什么是Node-JS"><a href="#什么是Node-JS" class="headerlink" title="什么是Node.JS"></a>什么是Node.JS</h2><blockquote>
<p>Node.js® is a JavaScript runtime built on <a target="_blank" rel="noopener" href="https://v8.dev/">Chrome’s V8 JavaScript engine</a>.</p>
<p>Node.JS是一个基于V8 JavaScript引擎的JavaScript运行时环境。</p>
<p align="right"><a target="_blank" rel="noopener" href="https://nodejs.org/en/">— Node.js</a></p>

</blockquote>
<p>接下来讨论以下几个问题</p>
<ol>
<li>什么是JavaScript运行环境</li>
<li>为什么JavaScript需要特别的运行环境</li>
<li>什么是JavaScript引擎</li>
<li>什么是V8</li>
</ol>
<h3 id="JavaScript无处不在"><a href="#JavaScript无处不在" class="headerlink" title="JavaScript无处不在"></a>JavaScript无处不在</h3><p><strong><a target="_blank" rel="noopener" href="https://stackoverflow.com/">Stack Overflow</a>创立者之一</strong>的Jeff Atwood在2007年提出了著名的 <strong>Atwood</strong>定律</p>
<blockquote>
<p>Any application that can be written in JavaScript, will eventually be written in JavaScript.</p>
<p>任何可以使用JavaScript来实现的应用最终都会使用JavaScript来实现。</p>
<p align="right">— Jeff Atwood</p>

</blockquote>
<p>但是在发明之初，JavaScript的目的是应用于在浏览器执行简单的脚本任务，对浏览器以及其中的DOM进行各种操作，所以JavaScript的应用场景非常受限</p>
<p>Atwood定律更像是一种美好的愿景，在当时看来还没有实现的可能性，但是随着Node.js的出现，Atwood定律已经越来越多的被证实是正确的</p>
<p>但是为了可以理解Node.js到底是如何帮助我们做到这一点的，我们就必须要了解JavaScript是如何被运行的</p>
<h3 id="浏览器内核是什么"><a href="#浏览器内核是什么" class="headerlink" title="浏览器内核是什么"></a>浏览器内核是什么</h3><p>不同的浏览器有不同的内核组成</p>
<ul>
<li><strong>Gecko</strong>：早期被Netscape和Mozilla Firefox浏览器使用</li>
<li><strong>Trident</strong>：微软开发，被IE4~IE11浏览器使用，但是Edge浏览器已经转向Blink</li>
<li><strong>Webkit</strong>：苹果基于KHTML开发（开源），用于Safari，Google Chrome（旧版）</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Node.js" style=color:#00a596>
                Node.js
            </a>
        </span>
        
    </div>

    <a href="/2021/10/27/邂逅NodeJS/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/10/16/矩阵/">
        <h2>
            矩阵
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/数学">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                数学
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/10/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="矩阵定义及其基本运算"><a href="#矩阵定义及其基本运算" class="headerlink" title="矩阵定义及其基本运算"></a>矩阵定义及其基本运算</h2><h3 id="矩阵的定义"><a href="#矩阵的定义" class="headerlink" title="矩阵的定义"></a>矩阵的定义</h3><p>由  $m\times n$ 个数 $a_{ij}(i=1,2,\cdots,n)$ 排成的 $m$ 行 $n$ 列的矩形表格</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn} \\
\end{bmatrix}</script><p>称为一个 $m\times n$ 矩阵, 简记为 $A$ 或 $(a_{ij})_{m\times n}(i=1,2,\cdots,m;j=1,2,\cdots,n)$, 当 $m=n$ 时, 称 $A$ 为 $n$ 阶<strong>方阵</strong></p>
<p>两个矩阵 $A=(a_{ij})_{m\times n}, B=(b_{ij})_{s\times k}$, 若 $m=s, n=k$, 则称 $A$ 与 $B$ 为同型矩阵</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/矩阵" style=color:#03a9f4>
                矩阵
            </a>
        </span>
        
    </div>

    <a href="/2021/10/16/矩阵/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/10/12/行列式/">
        <h2>
            行列式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/数学">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                数学
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/10/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <blockquote>
<p>二阶行列式是由两个二维向量组成的, 其 ( 运算规则的 ) 结果为以这两个向量为邻边的平行四边形的面积</p>
</blockquote>
<h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><ol>
<li><p>行列互换, 其值不变, 即 $|A|=|A^T|$</p>
</li>
<li><p>行列式中某行 ( 列 ) 元素全为零, 则行列式为零
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/行列式" style=color:#ffa2c4>
                行列式
            </a>
        </span>
        
    </div>

    <a href="/2021/10/12/行列式/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/08/20/数二专题内容/">
        <h2>
            数二专题
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/数学">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                数学
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/8/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="一元函数微分学应用"><a href="#一元函数微分学应用" class="headerlink" title="一元函数微分学应用"></a>一元函数微分学应用</h2><h3 id="物理应用"><a href="#物理应用" class="headerlink" title="物理应用"></a>物理应用</h3><p>已知质点运动的<strong>位移</strong> $s$ 关于时间 $t$ 的函数为 $s=s(t)$, 称它为质点的运动方程 ( <strong>运动方程</strong> ), 则其速度为</p>
<script type="math/tex; mode=display">
v=\lim_\limits{\Delta t\to 0}\frac{\Delta s}{\Delta t}=s'(t)</script><p>其加速度为</p>
<script type="math/tex; mode=display">
a(t)=\lim_\limits{\Delta t\to0}\frac{\Delta v}{\Delta t}=v'(t)=s''(t)</script><p>这就是导数的物理意义</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/数二" style=color:#ffa2c4>
                数二
            </a>
        </span>
        
    </div>

    <a href="/2021/08/20/数二专题内容/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/08/15/一元函数积分学/">
        <h2>
            一元函数积分学
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/数学">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                数学
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/8/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h2><h3 id="原函数与不定积分"><a href="#原函数与不定积分" class="headerlink" title="原函数与不定积分"></a>原函数与不定积分</h3><p>设函数 $f(x)$​ 定义在某区间 $I$​ 上, 若存在可导函数 $F(x)$​, 对于<strong>该区间上任意一点</strong>都有 $F’(x)=f(x)$ 成立, 则称 $F(x)$ 是 $f(x)$ 在区间 $I$ 上的一个原函数, 称 $\int f(x)dx=F(x)+C$ 为 $f(x)$ 在区间 $I$ 上的<strong>不定积分</strong>, 其中 $C$​ 为任意常数</p>
<h3 id="原函数-不定积分-存在定理"><a href="#原函数-不定积分-存在定理" class="headerlink" title="原函数 ( 不定积分 ) 存在定理"></a>原函数 ( 不定积分 ) 存在定理</h3><ol>
<li>连续函数 $f(x)$ 必有原函数 $F(x)$</li>
<li>含有第一类间断点、无穷间断点的函数 $f(x)$​ 在包含该间断点的区间内<strong>必没有</strong>原函数 $F(x)$</li>
</ol>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/积分" style=color:#00a596>
                积分
            </a>
        </span>
        
    </div>

    <a href="/2021/08/15/一元函数积分学/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/08/14/零点问题与微分不等式/">
        <h2>
            零点问题与微分不等式
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/数学">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                数学
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/8/14
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="零点问题"><a href="#零点问题" class="headerlink" title="零点问题"></a>零点问题</h2><p>方程 $f(x)=0$ 的根就是函数 $f(x)$ 的零点, 从几何上讲, 方程的根作为两条曲线的交点, 代数语言 “$f(x)=g(x)$” 的根与几何语言”曲线 $f(x)$ 与 $g(x)$ 的交点”, 两者概念不同, 但描述的是同一件事, 基于此, 为讨论方程的根, 有时可改为讨论曲线的交点, 讨论方程根的问题 ( 也成为函数的零点问题 ) 通常可以考虑下面这些方法</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/微分" style=color:#00bcd4>
                微分
            </a>
        </span>
        
    </div>

    <a href="/2021/08/14/零点问题与微分不等式/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/08/12/中值定理解题手法/">
        <h2>
            中值定理解题方法
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/数学">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                数学
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/8/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="型一-罗尔"><a href="#型一-罗尔" class="headerlink" title="型一: 罗尔"></a>型一: 罗尔</h2><h3 id="f-n-xi-0"><a href="#f-n-xi-0" class="headerlink" title="$f^{(n)}(\xi)=0$"></a>$f^{(n)}(\xi)=0$</h3><ol>
<li>$f’(\xi)=0: f(a)=f(b)$</li>
<li>$f’’(\xi)=0: \begin{cases}f(a)=f(c)=f(b)\\f’(\xi_1)=f’(\xi_2)\end{cases}$</li>
</ol>
<h2 id="型二-仅有-xi-无其他字母"><a href="#型二-仅有-xi-无其他字母" class="headerlink" title="型二:仅有 $\xi$, 无其他字母"></a>型二:仅有 $\xi$, 无其他字母</h2><h3 id="Case-1-还原法"><a href="#Case-1-还原法" class="headerlink" title="Case 1: 还原法"></a>Case 1: 还原法</h3><p>$条件=\begin{cases}\text{两项之和}=0 \\\text{导数差一阶}\end{cases}$</p>
<p>$\frac{f’(x)}{f(x)}=[\ln f(x)]’$</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/微分" style=color:#00a596>
                微分
            </a>
        </span>
        
    </div>

    <a href="/2021/08/12/中值定理解题手法/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/08/12/中值定理/">
        <h2>
            中值定理
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/数学">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                数学
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/8/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="有界与最值定理"><a href="#有界与最值定理" class="headerlink" title="有界与最值定理"></a>有界与最值定理</h2><p>设 $f(x)$ 在 $[a, b]$ 上连续, 则 $m\leq f(x)\leq M$, 其中, $m, M$ 分别为 $f(x)$ 在 $[a, b]$ 上的最小值与最大值</p>
<h2 id="介值定理"><a href="#介值定理" class="headerlink" title="介值定理"></a>介值定理</h2><p>设 $f(x)$ 在 $[a, b]$ 上连续, 当 $m\leq\mu\leq M$ 时, 存在 $\xi\in[a,b]$, 使得 $f(\xi)=\mu$</p>
<h2 id="平均值定理"><a href="#平均值定理" class="headerlink" title="平均值定理"></a>平均值定理</h2><p>设 $f(x)$ 在 $[a, b]$ 上连续, 当 $a&lt;x_1&lt;x_2&lt;\dots&lt;x_n&lt;b$ 时, 在 $[x_1, x_n]$ 内至少存在一点 $\xi$, 使</p>
<script type="math/tex; mode=display">
f(\xi)=\frac{f(x_1)+f(x_2)+\dots+f(x_n)}{n}</script>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/微分" style=color:#00a596>
                微分
            </a>
        </span>
        
    </div>

    <a href="/2021/08/12/中值定理/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2021/08/11/一元函数微分学/">
        <h2>
            一元函数微分学
        </h2>
    </a>

    <div class="category-and-date">

        
        <span class="category">
            <a href="/categories/数学">
                <span class="icon">
                    <a-icon type="book" theme="filled" /></span>
                数学
            </a>
        </span>
        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/8/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <script type="math/tex; mode=display">
\Delta y=A\Delta x +o(\Delta x)=y'dx+o(\Delta x)=dy+o(\Delta x)</script><script type="math/tex; mode=display">
\Delta y=dy+o(\Delta x)\Leftrightarrow\Delta y-dy=o(\Delta x)</script>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/微分" style=color:#ffa2c4>
                微分
            </a>
        </span>
        
    </div>

    <a href="/2021/08/11/一元函数微分学/ " class="go-post">
        阅读全文
    </a>
</div>



             
<div class="page-current">

    <div class="prev">
        
    </div>

    <div class="page-index">

        

        <span class="current">
            1
        </span>

        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/5">
                <span class="page-num">
                    5
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="/images/avatar.jpg " alt="头像">
        </div>
        <div class="name">
            Zhjh
        </div>
        <div class="descriptions">
            
            <div class="description">
                越努力越幸运!
            </div>
            
            <div class="description">
                付出总会有回报!
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a href="https://github.com/cszhjh" target="_blank">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="http://wpa.qq.com/msgrd?v=3&uin=15444087&site=qq&menu=yes" target="_blank">

                    
                    <a-icon type="qq"
                        theme="" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="/images/wechat.jpeg" target="_blank">

                    
                    <a-icon type="wechat"
                        theme="" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="mailto:cszhjh@icloud.com" target="_blank">

                    
                    <a-icon type="mail"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://coderlion.com">
                    国内博客
                </a>
            </div>
            
            <div class="friend-link">
                <a href="https://cszhjh.github.io">
                    Github博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>

    </div>
    
</div>

                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2021 Zhjh&#39;s Blog
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Zhjh
        </div>
        <!-- <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
        <div> -->
            备案号：<a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">
                琼ICP备 - 20001325号
            </a>
        </div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>

                </div>
            </div>
        </transition>
         <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
 
    </div>

    <script>
      new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight,
                    behavior: "smooth",
                });
            }
        }
    })
</script>


    <script src="/js/toc.js"></script>
</body>

</html>
